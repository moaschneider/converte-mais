<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Converte Mais 2.0</title>

    <!-- Sora -->
    <link href="https://fonts.googleapis.com/css2?family=Sora:wght@100..800&display=swap" rel="stylesheet">

    <!-- Libre Franklin -->
    <link href="https://fonts.googleapis.com/css2?family=Libre+Franklin:ital,wght@0,100..900;1,100..900&display=swap" rel="stylesheet">

    <!-- Century Gothic Paneuropean -->
    <link href="https://fonts.cdnfonts.com/css/century-gothic-paneuropean" rel="stylesheet">

    <!-- Roboto -->
    <link href="https://fonts.googleapis.com/css2?family=Roboto:ital,wght@0,100;0,300;0,400;0,500;0,700;0,900;1,100;1,300;1,400;1,500;1,700;1,900&display=swap" rel="stylesheet">

    <style>
        :root {
            --height: 70vh;
        }
        * {
            box-sizing: border-box;
            font-family: 'Sora', 'Century Gothic Paneuropean', 'Roboto', 'Libre Franklin', sans-serif;
            font-size: 15px;
        }
        body {
            /* background-color: #e6ffe6; */
            background-color: #ddd;
        }
        h1, h2, h3, h4, h5, h6 {
            font-weight: 500;
            color: #32ab53;
        }
        h1 {
            font-size: 27px;
        }
        h2 {
            font-size: 23px;
        }
        h3 {
            font-size: 21px;
        }
        h4 {
            font-size: 19px;
        }
        h5 {
            font-size: 17px;
        }
        h6 {
            font-size: 15px;
        }
        .b {
            border: 1px solid red;
        }
        .border {
            border: 0px solid black;
            border-radius: 20px;
        }
        pre {
            white-space: pre-wrap; /* Para preservar espaços e quebras de linha */
        }
        code {
            font-family: monospace;
            white-space: pre;
        }
        sub, sup {
            font-size: 11px;
        }
        .margin {
            margin: 0 auto;
            width: 95%;
            display: flex;
            flex-direction: column;
        }
        header {
            display: flex;
            justify-content: space-between;
        }
        main {
            display: flex;
            /* flex-direction: column; */
            /* justify-content: space-between; */
            /* min-height: 100vh; */
            gap: 50px;
            /* padding: 10px; */
            min-height: var(--height);
        }
        footer {
            padding-top: 50px;
        }
        .entry-data {
            width: 100%;
            flex-grow: 1;
        }
        .author {
            font-size: 14px;
            opacity: 0.8;
        }
        #textInput {
            width: 100%;
            height: var(--height);

            padding: 20px;
            font-size: 15px;
            line-height: 1.5em;
            resize: vertical;
        }
        .buttons {
            max-width: 100%;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            gap: 10px;
        }
        .buttons__functions {
            max-width: 70%;
            display: flex;
            align-items: flex-start;
            flex-wrap: wrap;
            gap: 5px;
        }
        .buttons__functions__tags, .buttons__functions__copy {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
        }
        .buttons__functions__tags button, .buttons__functions__copy button {
            cursor: pointer;
        }
        .buttons__functions__tags {
            display: none;
        }
        #copyTextButton, #copyHtmlButton, #generateButton, #shortcutsButton {
            font-size: 12px;
            font-weight: bold;
            text-transform: uppercase;
            padding: 8px 16px;
            color: white;
            border-radius: 30px;
            /* outline: 0; */
        }
        #generateButton {
            color: black;
            background-color: limegreen;
            border-color: limegreen;
        }
        #copyTextButton, #copyHtmlButton, #shortcutsButton {
            background-color: black;
            border: 0.5px solid black;
        }
        #shortcutsButton {
            background-color: grey;
            border: 0.5px solid grey;
        }
        .textos {
            margin: 30px 0 100px 0;
            width: 100%;
            display: none;
            flex-direction: column;
            gap: 15px;
        }
        .textos__html {
            width: 100%;
            padding: 20px;
            display: flex;
            flex-direction: column;
            background-color: white;
            margin-bottom: 30px;
            line-height: 1.5em;
            /* border: 1px solid black; */
            /* border-radius: 10px; */
        }
        #htmlListaDeImagens {
            width: 100%;
            display: flex;
            flex-direction: row;
            flex-wrap: wrap;
            gap: 5px;
        }
        #htmlListaDeImagens img {
            width: 240px;
            object-fit: cover;
        }
        table {
            border-collapse: collapse;
        }
        th {
            text-align: left;
        }
        td, th {
            border: 1px solid black;
            padding: 5px;
        }
        img {
            max-width: 100%;
        }
        .tooltip {
        position: relative;
        display: inline-block;
        }

        .tooltip .tooltiptext {
        visibility: hidden;
        width: 60px;
        background-color: black;
        color: #fff;
        text-align: center;
        padding: 5px;
        border-radius: 5px;
        font-size: 15px;
        font-weight: normal;
        
        /* Posição da tooltip */
        position: absolute;
        z-index: 1;
        bottom: 130%;
        left: 50%;
        margin-left: -30px;
        
        /* Efeito de transição */
        opacity: 0;
        transition: opacity .8s;
        }
        .tooltip:hover .tooltiptext {
        visibility: visible;
        opacity: 1;
        }
        #generateButton .tooltiptext {
            width: 110px;
        }
        span {
            font-size: inherit;
        }
        blockquote {
            border-left: 5px solid #ccc;
            padding-left: 15px;
            margin-inline-start: 40px;
            margin-inline-end: 40px;
        }
        #iframe {
        max-width: 100%;
        width: 100%;
        height: var(--height);
        resize: vertical;
        /* border-radius: 0; */
        /* border: none; */
        }

        @media screen and (max-width: 900px){
            main {
                display: block;
                /* display: flex; */
                /* flex-direction: column; */
                /* justify-content: space-between; */
                /* min-height: 100vh; */
                /* gap: 50px; */
                /* padding: 10px; */
                min-height: var(--height);
            }
            #entry-data-pdf {
                display: none;
            }
        }

        .pdf-controls {
            display: flex;
            justify-content: flex-end;
            gap: 10px;
            align-items: center;
            margin-top: 10px;
        }

        .file-input {
            font-size: 12px;
            font-weight: bold;
            text-transform: uppercase;
            color: white;
            background-color: black;
            border: 0.5px solid black;
            border-radius: 30px;
            padding: 8px 16px;
            cursor: pointer;
        }

        .file-input::-webkit-file-upload-button {
            display: none;
        }

        /* Esconde o texto padrão do input */
        .file-input {
            color: transparent; /* Torna o texto do input transparente */
        }

        .file-input::before {
            content: 'SELECIONAR PDF';
            display: inline-block;
            cursor: pointer;
            color: white; /* Restaura a cor do texto apenas para o pseudo-elemento */
            position: absolute;
        }

        .file-input.file-selected::before {
            content: attr(data-file-name);
        }

        .pdf-button {
            font-size: 12px;
            font-weight: bold;
            text-transform: uppercase;
            color: white;
            background-color: black;
            border: 0.5px solid black;
            border-radius: 30px;
            padding: 8px 16px;
            cursor: pointer;
        }
    </style>
</head>
<body>

    <div class="margin">
        <header>
            <h1>Converte Mais</h1>
            <p><a href="index-old.html">Link para versão 1.0</a></p>
        </header>

        <main>
            <div class="entry-data" id="entry-data-content">
                
                <textarea id="textInput" class="border" rows="10" cols="50" placeholder="1) Entre aqui o texto copiado&#10;&#10;2) Aplique os marcadores&#10;&#10;3) Clique em 'GERAR' (ctrl + enter) para converter&#10;&#10;4) Utilize os botões 'COPIAR TEXTO' ou 'COPIAR HTML'.">## Primeiros passos ## (p)

Essa é uma ferramenta desenvolvida para te ajudar a converter conteúdos em .pdf para textos simples e html. A ferramenta utiliza marcações entre parênteses como, por exemplo, a letra "p" minúscula dentro de parênteses, que é o marcador de parágrafo. (p)

#### Negrito, itálico e gerar conversão  #### (p)

Para dar agilidade, utilize as teclas de atalho. Por exemplo, para atribuir negrito pressione "alt + x", para itálico use "alt + z". Essa é a aparência do texto em (st)negrito(st) e do texto em (em)itálico(em). Para ver como essas marcações funcionam clique no botão "GERAR" abaixo ou use o atalho "ctrl + enter". Role a tela para baixo e veja como os marcadores sumiram e converteram o texto em parágrafo e atribuiram os estilos negrito e itálico.(p)

#### Listas  #### (p)

Você pode criar listas não ordenadas usando "alt + d" na frente dos itens da lista:(p)

(ul)para cada item;
(ul)você deve colocar o marcador no início;
(ul)a ferramenta converte automaticamente a primeira letra de itens de lista em maiúscula :)
(ul)não esqueça de usar o marcador de parágrafo para encerrar a lista.(p)

Para criar listas ordenadas use "alt + f":(p)

(ol)fácil,
(ol)rápido,
(ol)prático!(p)

#### Bloco de citação longa #### (p)

Para criar uma citação longa use o atalho "alt + k":(p)

(p)(block)(p)
O bloco de texto já fica automaticamente recuado e com uma barra vertical do lado parágrafo para se destacar do restante do texto.(p)
É possível também usar o marcador de parágrafo para criar outros parágrafos dentro do bloco de citação longa.
(p)(/block)(p)

#### Imagens  #### (p)

É possível também adicionar uma imagem de algum endereço web. Basta usar o atalho "alt + i" e substituir o endereço da imagem pelo parâmetro "URL". Faça o teste abaixo:(p)

Copie o endereço "https://converte-mais.vercel.app/amazonia.jpg" e substitua no código abaixo:(p) 

(p) (img) URL | LEGENDA | FONTE | DESCRIÇÃO (p)

Os outros parâmetros também podem ser substituidos. Faça o teste e substitua o parâmetro "LEGENDA" por um texto adequado ("Vista da floresta amazônica", por exemplo) e um texto que descreva a imagem para uma pessoa cega pelo parâmetro "DESCRIÇÃO".(p)
                </textarea><br><br>

                <div id="" class="buttons">
                    <div class="buttons__functions">
                        <div class="buttons__functions__copy">
                            <button id="copyTextButton">COPIAR TEXTO</button>
                            <button id="copyHtmlButton">COPIAR HTML</button>
                            <button id="shortcutsButton">Atalhos</button>
                        </div>
                    </div>
                    <button id="generateButton" class="tooltip" onclick="generateText()">Gerar
                        <span class="tooltiptext">Ctrl + Enter</span>
                    </button>
                </div>
                

                <div class="textos">
                    <div class="textos__html border">
                        <!-- <h4>TEXTO SEM FORMATAÇÃO</h4> -->
                        <div id="htmlResultado"></div>
                    </div>
                    <div class="textos__html border">
                        <h4>HTML</h4>
                        <pre id="htmlCodigo" class="textos__html__gerado"></pre>
                    </div>
                    <div class="textos__html border">
                        <h4>LISTA DE IMAGENS</h4>
                        <div id="htmlListaDeImagens" class="textos__html__gerado">
                        </div>
                    </div>
                </div>
            </div>

            <div class="entry-data" id="entry-data-pdf">
                <iframe id="iframe" class="border"></iframe>
                <div class="pdf-controls">
                    <input type="file" id="fileInput" accept=".pdf" class="file-input" onchange="handleFileSelect(this)" />
                </div>
            </div>
        </main>

        <footer>
            <p class="author">Desenvolvido por Moa Schneider • Versão 2.0</p>
        </footer>


        
    </div>


    <script>
        // Função para carregar a URL do localStorage
        function carregarPdf() {
            const input = document.getElementById('fileInput');
            if (input.files && input.files[0]) {
                const fileURL = URL.createObjectURL(input.files[0]);
                const iframe = document.getElementById('iframe');
                iframe.src = fileURL;
                
                // Atualiza o texto do botão para mostrar o nome do arquivo
                input.setAttribute('data-file-name', input.files[0].name.toUpperCase());
            }
        }

        // Evento para carregar o PDF do arquivo selecionado
        document.getElementById("fileInput").addEventListener("change", function(event) {
        const file = event.target.files[0];
        // if (file && file.type === "application/pdf") {
            const fileURL = URL.createObjectURL(file); // Cria uma URL temporária para o arquivo
            const iframe = document.getElementById("iframe");
            iframe.src = fileURL; // Define a URL como fonte do iframe
        // } else {
        //   alert("Por favor, selecione um arquivo PDF.");
        // }
        });

        // Carregar automaticamente a URL salva ao iniciar a página
        window.onload = carregarPdf;


        // Variáveis que recebem os diversos processamentos e que vão ser inseridas nas divs
        let htmlOutput = '';
        let htmlResultado = '';
        let htmlListaDeImagens = '';

        // Nomes das divs onde entra o html código e o html resultante
        const htmlCodigoDiv = document.getElementById('htmlCodigo');
        const htmlResultadoDiv = document.getElementById('htmlResultado');
        const htmlListaDeImagensDiv = document.getElementById('htmlListaDeImagens');

        // ::: PROCESSA BOLD E ITÁLICO :::
        function converteInlineTags(text) {

            text = text.replace(/\(st\)(.*?)\(st\)/g, '<strong>$1</strong>'); // Negrito com (st)
            text = text.replace(/\(em\)(.*?)\(em\)/g, '<em>$1</em>'); // Negrito com (em)
            text = text.replace(/\(sup\)(.*?)\(sup\)/g, '<sup>$1</sup>'); // Superescrito com (sup)
            text = text.replace(/\(sub\)(.*?)\(sub\)/g, '<sub>$1</sub>'); // Subscrito com (sub)
            text = text.replace(/\(code\)(.*?)\(code\)/g, '<code>$1</code>'); // Code com (code)
            text = text.replace(/\(br\)/g, '<br>'); // Insere quebra de linha <br>

            // DESABILITADA POR QUESTÃO DO <SPAN> MAS FUNCIONANDO
            // Solução para não evitar quebrar frases pequenas dentro de células de tabela
            // text = text.replace(/\(pre\)(.*?)\(pre\)/g, '<span style="white-space: nowrap;">$1</span>'); // Insere tag <pre>

            text = destacarPalavras(text);

            return text;
        }

        // Destacar palavras e letras "proibidas"
        const palavrasProibidas = ['alunos', 'aluno', 'aluna', 'alunas', '\\?'];
        const unidadesMedida = ['ºC', 'kg', 'm2', 'mm', 'km', 'L', 'ml', 'm', 'g', 'cm', 'Ω', 'KΩ', 'MΩ', 'V', 'W', 'Hz'];


        function destacarPalavras(texto) {
            palavrasProibidas.forEach(palavra => {
                // Tratar o ponto de interrogação separadamente
                if (palavra === '\\?') {
                    texto = texto.replace(/([\p{L}\w]+)\?/gu, '<span style="color: red; font-weight: bold;">$1?</span>');
                } else {
                    // Regex com bordas de palavras para outras palavras proibidas
                    const regex = new RegExp(`\\b(${palavra})\\b`, 'gi');
                    texto = texto.replace(regex, '<span style="color: red; font-weight: bold;">$1</span>');
                }
            });
            
            // Remove as barras invertidas que escapam os pontos de interrogação
            texto = texto.replace(/\\\?/g, '?');
            
            // Destacar números sem espaço antes das unidades de medida
            unidadesMedida.forEach(unidade => {
                const regex = new RegExp(`(\\d+)(${unidade})`, 'g'); // detecta números seguidos diretamente pela unidade
                texto = texto.replace(regex, '<span style="color: red; font-weight: bold;">$1$2</span>');
            });
            


            // Destaca palavras possivelmente quebradas com hífen
            texto = texto.replace(/(\w+[-][\s]+\w+)/gi, '<span style="color: red; font-weight: bold;">$1</span>');

            // Elimina hífen e une as duas partes de palavra quebrada por hifenização. Status: desabilitada, está funcionando, só tem que avaliar pra talvez colocar em um botão.
            // texto = texto.replace(/(\w+)[-][\s+](\w+)/gi, '$1$2');

            return texto;    
        }

        function limpaTexto(texto){
            return texto
            .replace(/[\r\n]+/g, ' ')        // Remove quebra de linha
            .replace(/\s{2,}/g, ' ')     // Remove espaços excessivos
            .trim();                    // Remove espaços no início e no final
        }

        // ::: 1 - RECEBE O TEXTO, REMOVE ESPAÇOS E QUEBRAS EXCESSIVAS E PROCESSA PARÁGRAFOS :::
        function generateText() {
            
            let textInput = document.getElementById('textInput').value;
            
            // Divide o texto em parágrafos usando (p)
            const paragraphs = textInput.split('(p)').map(p => p.trim()).filter(p => p.length > 0);
            // console.log(paragraphs);
            
            // Variáveis que recebem os diversos processamentos ao longo do script e que vão ser inseridas nas divs
            htmlOutput = '';
            htmlResultado = '';
            htmlListaDeImagens = '';
            
            processarParagrafos(paragraphs);

            // Mostra a div com os previews de texto e html
            document.querySelector('.textos').style.display = 'flex';


            const htmlOutputAjustado = removeEspacamentoDuplicado(htmlOutput);
            
            htmlCodigoDiv.textContent = htmlOutputAjustado;
            htmlResultadoDiv.innerHTML = htmlOutputAjustado;
            htmlListaDeImagensDiv.innerHTML = htmlListaDeImagens;
        }

        function removeEspacamentoDuplicado(html) {
            // Regex que encontra uma ou mais repetições consecutivas de <p><br></p>
            const regex = /(<p><br><\/p>\s*)+/g;
            
            // Substitui qualquer repetição por apenas uma ocorrência
            return html.replace(regex, '<p><br></p>\n\n');
        }


        // ::: 2 - PROCESSA OS PARÁGRAFOS ::: 
        function processarParagrafos(paragraphs) {
            let photoNumber = 1;
            let contador = 1;
            paragraphs.forEach(paragraph => {

            // Se for uma tag <pre>, pula a remoção de espaços
            if (paragraph.startsWith('(pre)')) {
                const preContent = paragraph.replace('(pre)', ''); // Remove (pre) sem remover espaços
                
                // Simula o <pre> usando div com white-space
                    htmlOutput += `<div style="white-space: pre-wrap;">${converteInlineTags(preContent)}</div>\n\n`;
                    
            } else if (paragraph.startsWith('(precode)')) {
                const precodeContent = paragraph.replace('(precode)', '');
                htmlOutput += `<pre>\n<code>${converteInlineTags(precodeContent)}</code>\n</pre>\n\n`;
            } else {
                // Se não for <pre> remove quebras e espaços excessivos
                paragraph = limpaTexto(paragraph);

                // Converte hashtags em títulos ou mantém como parágrafo
                const convertedText = converteTitulos(paragraph);  
                
                // Detecta uma tabela e processa
                if (paragraph.startsWith('(table)') && paragraph.endsWith('(table)')) {
                    
                    const tableContent = paragraph.replace(/^\(table\)|\(table\)$/g, '').trim();
                    const tableHtml = textToHtmlTable(tableContent);
                    
                    htmlOutput += tableHtml + '\n\n';
                    

                } else if (paragraph.startsWith('(box)')) {
                    // Remove o marcador (box) sem remover espaços
                    const boxContent = paragraph.replace('(box)', '').trim();
                    
                    // Envolve o conteúdo com a tag <div>
                    htmlOutput += `<div style="margin-top: 15px; padding: 10px; border: 2px solid #dfdfdf; background-color:#f2f2f2">\n\n\t${boxContent}`;

                } else if (paragraph.startsWith('(/box)')) {
                    // Remove o marcador (/box) sem remover espaços
                    const boxContent = paragraph.replace('(/box)', '').trim();
                    
                    // Envolve o conteúdo com a tag </div>
                    htmlOutput += `${boxContent}</div>\n\n`;


                } else if (paragraph.startsWith('(block)')) {
                    // Remove o marcador (block) sem remover espaços
                    const blockquoteContent = paragraph.replace('(block)', '').trim();
                    
                    // Envolve o conteúdo com a tag <blockquote>
                    htmlOutput += `<blockquote>\n\n${blockquoteContent}`;

                } else if (paragraph.startsWith('(/block)')) {
                    // Remove o marcador (/block) sem remover espaços
                    const blockquoteContent = paragraph.replace('(/block)', '').trim();
                    
                    // Envolve o conteúdo com a tag <blockquote>
                    htmlOutput += `${blockquoteContent}</blockquote>\n\n`;
                
                } else if (paragraph.startsWith('(code)')) {
                    // Remove o marcador (code) sem remover espaços
                    const blockquoteContent = paragraph.replace('(code)', '').trim();
                    
                    // Envolve o conteúdo com a tag <code>
                    htmlOutput += `<code>${blockquoteContent}</code><br>\n\n`;

                } else if (paragraph.startsWith('(linha)')) {
                    // Remove o marcador (linha) sem remover espaços
                    const hrContent = paragraph.replace('(linha)', '').trim();
                    
                    // Insere a tag <hr>
                    htmlOutput += `<hr>\n\n`;

                } else if (paragraph.startsWith('(ul)')) {

                    const listItems = paragraph.split('(ul)').map(item => item.trim()).filter(item => item.length > 0);
                    
                    // #### TESTE (24/10)
                    // Aqui entra replace para tornar a primeira letra em maiúscula
                    const listItemsPrimeiraMaiuscula = listItems.map(item => 
                        item.replace(/^\s*([a-záéíóúàèìòùâêîôûãõçñäëïöü])/i, (match, p1) => p1.toUpperCase())
                    );
                    // #### TESTE
                    
                    
                    
                    htmlOutput += '<ul>\n' + listItemsPrimeiraMaiuscula.map(item => `\t<li>${converteInlineTags(item)}</li>`).join('\n') + '\n</ul>\n\n';

                } else if (paragraph.startsWith('(ol)')) {
                    const listItems = paragraph.split('(ol)').map(item => item.trim()).filter(item => item.length > 0);

                    // #### TESTE (24/10)
                    // Aqui entra replace para tornar a primeira letra em maiúscula
                    const listItemsPrimeiraMaiuscula = listItems.map(item => 
                        item.replace(/^\s*([a-záéíóúàèìòùâêîôûãõçñäëïöü])/i, (match, p1) => p1.toUpperCase())
                    );
                    // #### TESTE

                    if (listItems[0].startsWith('(x.)')){
                        listItems[0] = listItems[0].replace('(x.)', '');
                        htmlOutput += '<ol style="list-style-type: lower-alpha;">\n' + listItems.map(item => `\t<li>${converteInlineTags(item)}</li>`).join('\n') + '\n</ol>\n\n';
                    } else if (listItems[0].startsWith('(X.)')){
                        listItems[0] = listItems[0].replace('(X.)', '');
                        htmlOutput += '<ol style="list-style-type: upper-alpha;">\n' + listItems.map(item => `\t<li>${converteInlineTags(item)}</li>`).join('\n') + '\n</ol>\n\n';
                    } else if (listItems[0].startsWith('(i.)')){
                        listItems[0] = listItems[0].replace('(i.)', '');
                        htmlOutput += '<ol style="list-style-type: lower-roman;">\n' + listItems.map(item => `\t<li>${converteInlineTags(item)}</li>`).join('\n') + '\n</ol>\n\n';
                    } else if (listItems[0].startsWith('(I.)')){
                        listItems[0] = listItems[0].replace('(I.)', '');
                        htmlOutput += '<ol style="list-style-type: upper-roman;">\n' + listItems.map(item => `\t<li>${converteInlineTags(item)}</li>`).join('\n') + '\n</ol>\n\n';
                    } else if (listItems[0].startsWith('(0.)')){
                        listItems[0] = listItems[0].replace('(0.)', '');
                        htmlOutput += '<ol style="list-style-type: decimal-leading-zero;">\n' + listItems.map(item => `\t<li>${converteInlineTags(item)}</li>`).join('\n') + '\n</ol>\n\n';
                    } 
                    else {
                        htmlOutput += '<ol>\n' + listItemsPrimeiraMaiuscula.map(item => `\t<li>${converteInlineTags(item)}</li>`).join('\n') + '\n</ol>\n\n';
                    }

                } else if (paragraph.startsWith('(img)')) {
                    // Processa figure e insere imagem de marcação
                    const imgContent = paragraph.replace('(img)', '').trim();

                    const autoFigureNumber = photoNumber++;

                    const [imgUrl, imgFigureCaption, imgSource, imgDescription] = imgContent.split('|').map(item => item.trim());

                    // Palavras proibidas em legenda e descrição de fotos
                    const imgFigureCaptionDestacado = destacarPalavras(imgFigureCaption);
                    const imgDescriptionDestacado = destacarPalavras(imgDescription);


                    // CÓDIGO PARA ADICIONAR URL DA FOTO VALENDO
                    htmlOutput += `<figure>\n`;
                    
                    let imgSourceUrl;
                    
                    if (imgUrl === 'URL'){
                        htmlOutput += `\t<p style="text-align: center;">\n\t\t<img src="https://placehold.co/500x300/32ab53/black.png?text=${imgFigureCaptionDestacado}" alt="Descrição abaixo da imagem.">\n\t</p>\n`;
                        htmlListaDeImagens += `<img src="https://placehold.co/500x300/32ab53/black.png?text=${imgFigureCaptionDestacado}">\n`;
                    } else {
                        htmlOutput += `\t<p style="text-align: center;">\n\t\t<img src="${imgUrl || ''}" alt="Descrição abaixo da imagem.">\n\t</p>\n`;
                        htmlListaDeImagens += `<a href="#${contador}" onclick="copiaUrl('${imgUrl}')"><img id="${contador}" src="${imgUrl || ''}"></a>\n`;
                        imgSourceUrl = imgUrl;
                    }
                    contador++;

                    htmlOutput += `\t<p style="text-align: center;">Figura ${autoFigureNumber} - ${imgFigureCaptionDestacado || '\n'}<br>\n\t\t<sub>Fonte: ${imgSourceUrl || imgSource || ''}</sub>\n\t</p>\n`;
                    htmlOutput += `\t<p>\n\t\t<sub>Descrição da imagem: ${imgDescriptionDestacado || ''}</sub>\n\t</p>\n`;
                    htmlOutput += `</figure>\n\n`;
                    htmlOutput += `<p><br></p>\n\n`;

                } else if (paragraph.startsWith('(pcent)')){
                    const paragraphCentralized = paragraph.replace('(pcent)', '').trim();

                    htmlOutput += `<p style="text-align: center">${converteInlineTags(paragraphCentralized)}</p>\n\n`;
                
                } else {

                    // Adiciona o texto convertido no HTML
                    htmlOutput += convertedText + '\n\n';
                }
            }
            });
        }

        // FUNÇÃO PARA COPIAR A IMAGEM CORRETA PARA A ÁREA DE TRANSFERÊNCIA
        function copiaUrl(url){
            // console.log(url);
            const tempInput = document.createElement('input');
            tempInput.value = url;
            document.body.appendChild(tempInput);
            tempInput.select();
            document.execCommand('copy');
            document.body.removeChild(tempInput);
        }


        // ::: 3 - CONVERSÃO DE # EM TÍTULOS :::
        function converteTitulos(text) {

            const textAjustado = limpaTexto(text);
            // console.log(textAjustado);

            // Regex para detectar títulos
            const titleRegex = /^(#{1,6})\s*(.+?)\s*#{1,6}$/;

            
            // Se o texto corresponder ao padrão de título, retorna a tag de título
            const match = textAjustado.match(titleRegex);
            if (match) {
                const level = match[1].length; // O número de hashtags define o nível do título
                // console.log(level);
                const tituloPalavrasProibidas = destacarPalavras(match[2]);
                // console.log(tituloPalavrasProibidas);

                if (htmlOutput === '') {
                    return `<h${level}>${tituloPalavrasProibidas.trim()}</h${level}>`;
                } else {
                    return `<p><br></p>\n\n<h${level}>${tituloPalavrasProibidas.trim()}</h${level}>`;
                }
            }

            // Se não for título, retorna o texto original
            return `<p>${converteInlineTags(text)}</p>`;
        }


        // Define o texto das teclas de atalhos e botões simultaneamente
        const atalhos = {
            strong: {marcador: "(st)", tecla: "x"},
            em: {marcador: "(em)", tecla: "z"},
            ul: {marcador: "(ul)", tecla: "d"},
            ul2: {marcador: "(ul)", tecla: "a"},
            ol: {marcador: "(ol)", tecla: "f"},
            p: {marcador: "(p)", tecla: "s"},
            hr: {marcador: "(linha)", tecla: "l"},
            code: {marcador: "(code)", tecla: "c"},
            pre: {marcador: "(pre)", tecla: "p"},
            precode: {marcador: "(precode)", tecla: "ç"},
            br: {marcador: "(br)", tecla: "q"},
            th: {marcador: "(th)", tecla: "h"},
            thcentralizado: {marcador: "(th):", tecla: "j"},
            sub: {marcador: "(sub)", tecla: "u"},
            sup: {marcador: "(sup)", tecla: "y"},
            h1: {marcador: " # ", tecla: "1"},
            h2: {marcador: " ## ", tecla: "2"},
            h3: {marcador: " ### ", tecla: "3"},
            h4: {marcador: " #### ", tecla: "4"},
            h5: {marcador: " ##### ", tecla: "5"},
            h6: {marcador: " ###### ", tecla: "6"},
            img: {marcador: "\n(p) (img) URL | LEGENDA | FONTE | DESCRIÇÃO (p)\n", tecla: "i"},
            table: {marcador: "\n(p)(table)\n\n(table)(p)\n", tecla: "b", antes: "\n(p)(table)\n", depois: "\n(table)(p)\n"},
            blockquote: {marcador: "\n(p)(block)(p)\n\n(p)(/block)(p)\n", tecla: "k", antes: "\n(p)(block)(p)\n\n", depois: "\n\n(p)(/block)(p)\n" },
            box: {marcador: "\n(p)(box)(p)\n\n(p)(/box)(p)\n\n", tecla: "o", antes: "\n(p)(box)(p)\n\n", depois: "\n\n(p)(/box)(p)\n" },
        }

        // ::: COPIAR PARA ÁREA DE TRANSFERÊNCIA :::
        function copyToClipboard(content) {
            const tempInput = document.createElement('textarea');
            tempInput.value = content;
            document.body.appendChild(tempInput);
            tempInput.select();
            document.execCommand('copy');
            document.body.removeChild(tempInput);
        }


        // ::: COPIA TAGS DOS BOTÕES :::
        document.getElementById('copyHtmlButton').addEventListener('click', () => {
            const htmlContent = document.querySelector('#htmlCodigo').textContent;
            copyToClipboard(htmlContent);
        });


        // ::: COPIAR CÓDIGOS, TEXTOS E TECLAS DE ATALHO :::
        function copiarConteudoVisivel() {
            const htmlDiv = document.getElementById("htmlResultado");

            // Cria um intervalo de seleção
            const range = document.createRange();
            range.selectNodeContents(htmlDiv); // Seleciona todo o conteúdo visível da div

            // Limpa seleções anteriores
            const selection = window.getSelection();
            selection.removeAllRanges();

            // Adiciona o intervalo (o conteúdo da div) à seleção
            selection.addRange(range);

            // Executa o comando de cópia
            document.execCommand("copy");

            // Remove a seleção (opcional, para desfazer a seleção visível)
            selection.removeAllRanges();
        }

        // Evento de clique no botão para copiar
        document.getElementById("copyTextButton").addEventListener("click", copiarConteudoVisivel);

        const textarea = document.getElementById('textInput');

        // Função para inserir o marcador na posição atual do cursor
        function insertTextAtCursor(text) {
            const startPos = textarea.selectionStart;
            const endPos = textarea.selectionEnd;

            // Insere o texto na posição atual do cursor
            const beforeText = textarea.value.substring(0, startPos);
            const afterText = textarea.value.substring(endPos, textarea.value.length);
            textarea.value = beforeText + text + afterText;

            // Reposiciona o cursor após o texto inserido
            textarea.selectionStart = textarea.selectionEnd = startPos + text.length;

            // Foco de volta para a área de texto
            textarea.focus();
        }

        // Definições das teclas de atalho
        addEventListener('keydown', function(event){
            if (event.ctrlKey && event.key === 'Enter') {
                event.preventDefault(); // Evita o comportamento padrão
                generateText(); // Chama a função generateText()
            }
        })


        textarea.addEventListener('keydown', function(event) {
            
            if (event.altKey && event.ctrlKey && event.key.toLowerCase() === atalhos["p"]["tecla"]) {
                // event.preventDefault(); // Evita o comportamento padrão
                insertTextAtCursor(atalhos["p"]["marcador"] + '\n'); // Insere o texto "(p)"
            } else if (event.altKey && event.key.toLowerCase() === atalhos["p"]["tecla"]) {
                // event.preventDefault(); // Evita o comportamento padrão
                insertTextAtCursor(atalhos["p"]["marcador"]); // Insere o texto "(p)"
            }
            
            if (event.ctrlKey && event.key === 'Enter') {
                event.preventDefault(); // Evita o comportamento padrão
                generateText(); // Chama a função generateText()
            }
            
            // Atalho de lista não ordenada foi para junto do código para substituir bullets por seleção de texto (abaixo)

            if (event.altKey && event.key.toLowerCase() === atalhos["precode"]["tecla"]) {
                event.preventDefault(); // Evita o comportamento padrão
                insertTextAtCursor(atalhos["precode"]["marcador"] + '\n'); // Insere o texto "(precode)"
            }
            
            if (event.altKey && event.key.toLowerCase() === atalhos["code"]["tecla"]) {
                event.preventDefault(); // Evita o comportamento padrão
                insertTextAtCursor(atalhos["code"]["marcador"]); // Insere o texto "(code)"
            }
                        
            if (event.altKey && event.key.toLowerCase() === atalhos["pre"]["tecla"]) {
                event.preventDefault(); // Evita o comportamento padrão
                insertTextAtCursor(atalhos["pre"]["marcador"] + '\n'); // Insere o texto "(pre)"
            }
            
            if (event.altKey && event.key.toLowerCase() === atalhos["br"]["tecla"]) {
                event.preventDefault(); // Evita o comportamento padrão
                insertTextAtCursor(atalhos["br"]["marcador"]); // Insere o texto "(br)"
            }
            
            if (event.altKey && event.key.toLowerCase() === atalhos["hr"]["tecla"]) {
                event.preventDefault(); // Evita o comportamento padrão
                insertTextAtCursor(atalhos["hr"]["marcador"]); // Insere o texto "(linha)"
            }
            
            if (event.altKey && event.key.toLowerCase() === atalhos["th"]["tecla"]) {
                event.preventDefault(); // Evita o comportamento padrão
                insertTextAtCursor(atalhos["th"]["marcador"]); // Insere o texto "(th)"
            }
            
            if (event.altKey && event.key.toLowerCase() === atalhos["thcentralizado"]["tecla"]) {
                event.preventDefault(); // Evita o comportamento padrão
                insertTextAtCursor(atalhos["thcentralizado"]["marcador"]); // Insere o texto "(th):"
            }

            if (event.altKey && event.key.toLowerCase() === atalhos["strong"]["tecla"]) {
                // event.preventDefault(); // Evita o comportamento padrão
                insertTextAtCursor(atalhos["strong"]["marcador"]); // Insere o texto "(st)"
            }

            if (event.altKey && event.key.toLowerCase() === atalhos["sub"]["tecla"]) {
                // event.preventDefault(); // Evita o comportamento padrão
                insertTextAtCursor(atalhos["sub"]["marcador"]); // Insere o texto "(sub)"
            }

            if (event.altKey && event.key.toLowerCase() === atalhos["sup"]["tecla"]) {
                // event.preventDefault(); // Evita o comportamento padrão
                insertTextAtCursor(atalhos["sup"]["marcador"]); // Insere o texto "(sup)"
            }

            if (event.altKey && event.key.toLowerCase() === atalhos["em"]["tecla"]) {
                // event.preventDefault(); // Evita o comportamento padrão
                insertTextAtCursor(atalhos["em"]["marcador"]); // Insere o texto "(em)"
            }

            if (event.altKey && event.key.toLowerCase() === atalhos["h1"]["tecla"]) {
                // event.preventDefault(); // Evita o comportamento padrão
                insertTextAtCursor(atalhos["h1"]["marcador"]); // Insere o texto " #### "
            }

            if (event.altKey && event.key.toLowerCase() === atalhos["h2"]["tecla"]) {
                // event.preventDefault(); // Evita o comportamento padrão
                insertTextAtCursor(atalhos["h2"]["marcador"]); // Insere o texto " #### "
            }

            if (event.altKey && event.key.toLowerCase() === atalhos["h3"]["tecla"]) {
                // event.preventDefault(); // Evita o comportamento padrão
                insertTextAtCursor(atalhos["h3"]["marcador"]); // Insere o texto " #### "
            }

            if (event.altKey && event.key.toLowerCase() === atalhos["h4"]["tecla"]) {
                // event.preventDefault(); // Evita o comportamento padrão
                insertTextAtCursor(atalhos["h4"]["marcador"]); // Insere o texto " #### "
            }

            if (event.altKey && event.key.toLowerCase() === atalhos["h5"]["tecla"]) {
                // event.preventDefault(); // Evita o comportamento padrão
                insertTextAtCursor(atalhos["h5"]["marcador"]); // Insere o texto " ##### "
            }

            if (event.altKey && event.key.toLowerCase() === atalhos["h6"]["tecla"]) {
                // event.preventDefault(); // Evita o comportamento padrão
                insertTextAtCursor(atalhos["h6"]["marcador"]); // Insere o texto " ##### "
            }

            if (event.altKey && event.key.toLowerCase() === atalhos["img"]["tecla"]) {
                // event.preventDefault(); // Evita o comportamento padrão
                insertTextAtCursor(atalhos["img"]["marcador"]); // Insere imagem
            }

            if (event.altKey && event.key === atalhos["table"]["tecla"]) {
                event.preventDefault(); // Evita o comportamento padrão
                
                // Pega a posição de início e fim da seleção de texto
                let start = textarea.selectionStart;
                let end = textarea.selectionEnd;
                
                // O texto selecionado
                let selectedText = textarea.value.substring(start, end);
                
                // Adiciona os marcadores (p)(table) antes e depois da seleção
                let before = atalhos["table"]["antes"];
                let after = atalhos["table"]["depois"];
                let newText = before + selectedText + after;
                
                // Atualiza o conteúdo do textarea com os marcadores
                textarea.setRangeText(newText, start, end, 'end');
            }

            if (event.altKey && event.key === atalhos["box"]["tecla"]) {
                event.preventDefault(); // Evita o comportamento padrão
                
                // Pega a posição de início e fim da seleção de texto
                let start = textarea.selectionStart;
                let end = textarea.selectionEnd;
                
                // O texto selecionado
                let selectedText = textarea.value.substring(start, end);
                
                // Adiciona os marcadores (box) antes e depois da seleção
                let before = atalhos["box"]["antes"];
                let after = atalhos["box"]["depois"];
                let newText = before + selectedText + after;
                
                // Atualiza o conteúdo do textarea com os marcadores
                textarea.setRangeText(newText, start, end, 'end');
            } 

            if (event.altKey && event.key === atalhos["blockquote"]["tecla"]) {
                event.preventDefault(); // Evita o comportamento padrão
                
                // Pega a posição de início e fim da seleção de texto
                let start = textarea.selectionStart;
                let end = textarea.selectionEnd;
                
                // O texto selecionado
                let selectedText = textarea.value.substring(start, end);
                
                // Adiciona os marcadores (block) antes e depois da seleção
                let before = atalhos["blockquote"]["antes"];
                let after = atalhos["blockquote"]["depois"];
                let newText = before + selectedText + after;
                
                // Atualiza o conteúdo do textarea com os marcadores
                textarea.setRangeText(newText, start, end, 'end');
            } 

            if (event.altKey && event.ctrlKey && event.key === atalhos["ul"]["tecla"]) {
                event.preventDefault(); // Evita o comportamento padrão
                
                // Pega a posição de início e fim da seleção de texto
                let start = textarea.selectionStart;
                let end = textarea.selectionEnd;
                
                // O texto selecionado
                let selectedText = textarea.value.substring(start, end);
                
                // Verifica se há bullets "•" e substitui por "(ul)"
                if (selectedText.includes("•")) {
                    let newText = selectedText.replace(/•/g, "(ul)");
                    
                    // Atualiza o conteúdo do textarea com o novo texto sem perder o restante do conteúdo
                    textarea.setRangeText(newText, start, end, 'end');
                }
                
                // Verifica se há hifens "-" e substitui por "(ul)"
                if (selectedText.includes("-")) {
                    let newText = selectedText.replace(/-/g, "(ul)");
                    
                    // Atualiza o conteúdo do textarea com o novo texto sem perder o restante do conteúdo
                    textarea.setRangeText(newText, start, end, 'end');
                }
            } else if (event.altKey && event.key.toLowerCase() === atalhos["ul"]["tecla"]) {
                event.preventDefault(); // Evita o comportamento padrão
                insertTextAtCursor(atalhos["ul"]["marcador"]); // Insere o texto "(ul)"
            }

            if (event.altKey && event.ctrlKey && event.key === atalhos["ol"]["tecla"]) {
                event.preventDefault(); // Evita o comportamento padrão
                
                // Pega a posição de início e fim da seleção de texto
                let start = textarea.selectionStart;
                let end = textarea.selectionEnd;
                
                // O texto selecionado
                let selectedText = textarea.value.substring(start, end);
                
                // Verifica e substitui padrões como "X)", "X.", "X - " e "X-"
                let newText = selectedText.replace(/(?<!\()\b([a-zA-Z0-9])[\)\.\-](?!\))/g, "(ol)");
                
                // Atualiza o conteúdo do textarea com o novo texto sem perder o restante do conteúdo
                textarea.setRangeText(newText, start, end, 'end');
            } else if (event.altKey && event.key.toLowerCase() === atalhos["ol"]["tecla"]) {
                event.preventDefault(); // Evita o comportamento padrão
                insertTextAtCursor(atalhos["ol"]["marcador"]); // Insere o texto "(ol)"
            }
        });

        // ::: FUNÇÃO PARA SALVAR O TRABALHO NO LOCAL STORAGE :::
        function salvarTexto() {
            const text = textarea.value;
            localStorage.setItem('textoSalvo', text);
        }

        // Carregar o texto salvo ao abrir a página
        function carregarTexto() {
            const textoSalvo = localStorage.getItem('textoSalvo');
            if (textoSalvo) {
                textarea.value = textoSalvo;
            }
        }

        // Configurar o auto-salvamento a cada 5 segundos
        setInterval(salvarTexto, 5000);

        window.addEventListener('load', carregarTexto);


        // ::: PROCESSA TABELA :::
        function parseCell(cell) {
            let rowspanMatch = cell.match(/\(rowspan=(\d+)\)/);
            let colspanMatch = cell.match(/\(colspan=(\d+)\)/);
            let thMatch = cell.match(/\(th\)/);

            let rowspan = rowspanMatch ? parseInt(rowspanMatch[1]) : 1;
            let colspan = colspanMatch ? parseInt(colspanMatch[1]) : 1;
            let isHeader = thMatch ? true : false;

            cell = cell
                .replace(/\(rowspan=\d+\)/, "")
                .replace(/\(colspan=\d+\)/, "")
                .replace(/\(th\)/, "")
                .trim();

            let alignCenter = cell.startsWith(':');
            if (alignCenter) {
                cell = cell.slice(1).trim();
            }

            return { cell, rowspan, colspan, alignCenter, isHeader };
        }

        function textToHtmlTable(text, columnSeparator = ";", rowSeparator = ";;") {
            // Substitui "\;" por valores temporários que não interferem na separação
            text = text.replace(/\\;/g, "__ESCAPED_SEMICOLON__");

            const rows = text.split(rowSeparator).map(row => row.trim());
            let html = "<table border='1' align='center'>\n";
            let table = [];

            rows.forEach((row, rowIndex) => {
                let cells = row.split(columnSeparator).map(cell => cell.trim());
                table[rowIndex] = table[rowIndex] || [];

                cells.forEach((cell, colIndex) => {
                    let { cell: cellContent, rowspan, colspan, alignCenter, isHeader } = parseCell(cell);

                    if (rowspan > 1) {
                        for (let i = 0; i < rowspan; i++) {
                            table[rowIndex + i] = table[rowIndex + i] || [];
                            table[rowIndex + i][colIndex] = {
                                content: cellContent,
                                rowspan: rowspan,
                                colspan: colspan,
                                merged: i > 0,
                                alignCenter,
                                isHeader
                            };
                        }
                    } else {
                        if (!table[rowIndex][colIndex]) {
                            table[rowIndex][colIndex] = {
                                content: cellContent,
                                rowspan: rowspan,
                                colspan: colspan,
                                merged: false,
                                alignCenter,
                                isHeader
                            };
                        }
                    }
                });
            });

            table.forEach(row => {
                html += "  <tr>\n";
                row.forEach(cell => {
                    if (cell && !cell.merged) {
                        let tag = cell.isHeader ? 'th' : 'td';
                        let style = cell.alignCenter ? ' style="text-align: center;"' : '';
                        html += `    <${tag}${style}${cell.rowspan > 1 ? ` rowspan="${cell.rowspan}"` : ""}${cell.colspan > 1 ? ` colspan="${cell.colspan}"` : ""}>${converteInlineTags(cell.content)}</${tag}>\n`;
                    }
                });
                html += "  </tr>\n";
            });

            html += "</table>\n\n";
            html += "<p><br></p>";

            // Reverte os valores temporários para ";"
            html = html.replace(/__ESCAPED_SEMICOLON__/g, ";");
            // console.log(html);

            // Converte lista dentro de tabela
            html = html.replace(/<(td|th)>(.*?)<\/\1>/g, (match, tag, content) => {
                // Captura o texto antes do primeiro (ul) ou (ol)
                const beforeList = content.split(/\s*\(ul\)/)[0].split(/\s*\(ol\)/)[0];
                // console.log(beforeList);
                const itemsUl = content.split(/\s*\(ul\)/).slice(1); // Divide e ignora a parte antes do primeiro (ul)
                const itemsOl = content.split(/\s*\(ol\)/).slice(1); // Divide e ignora a parte antes do primeiro (ol)
                
                let listHtml = content; // Default to the original content
                if (itemsUl.length > 0 && itemsUl[0].trim() !== '') {
                    const listItems = itemsUl.map(item => `<li>${item.trim()}</li>`).join('');
                    listHtml = `${beforeList} <ul>${listItems}</ul>`;
                } else if (itemsOl.length > 0 && itemsOl[0].trim() !== '') {
                    if (itemsOl[0].startsWith('(x.)')){
                        itemsOl[0] = itemsOl[0].replace('(x.)', '');
                        const listItems = itemsOl.map(item => `<li>${item.trim()}</li>`).join('');
                        listHtml = `${beforeList} <ol style="list-style-type: lower-alpha;">${listItems}</ol>`;
                    } else if (itemsOl[0].startsWith('(X.)')){
                        itemsOl[0] = itemsOl[0].replace('(X.)', '');
                        const listItems = itemsOl.map(item => `<li>${item.trim()}</li>`).join('');
                        listHtml = `${beforeList} <ol style="list-style-type: upper-alpha;">${listItems}</ol>`;
                    } else if (itemsOl[0].startsWith('(i.)')){
                        itemsOl[0] = itemsOl[0].replace('(i.)', '');
                        const listItems = itemsOl.map(item => `<li>${item.trim()}</li>`).join('');
                        listHtml = `${beforeList} <ol style="list-style-type: lower-roman;">${listItems}</ol>`;
                    } else if (itemsOl[0].startsWith('(I.)')){
                        itemsOl[0] = itemsOl[0].replace('(I.)', '');
                        const listItems = itemsOl.map(item => `<li>${item.trim()}</li>`).join('');
                        listHtml = `${beforeList} <ol style="list-style-type: upper-roman;">${listItems}</ol>`;
                    } else if (itemsOl[0].startsWith('(0.)')){
                        itemsOl[0] = itemsOl[0].replace('(0.)', '');
                        const listItems = itemsOl.map(item => `<li>${item.trim()}</li>`).join('');
                        listHtml = `${beforeList} <ol style="list-style-type: decimal-leading-zero;">${listItems}</ol>`;
                    } else {
                        const listItems = itemsOl.map(item => `<li>${item.trim()}</li>`).join('');
                        listHtml = `${beforeList} <ol>${listItems}</ol>`;

                    }
                }

                return `<${tag}>${listHtml}</${tag}>`;
            });

            return html;
        }

        function handleFileSelect(input) {
            if (input.files && input.files[0]) {
                input.classList.add('file-selected');
                carregarPdf();
            }
        }

    </script>
</body>
</html>